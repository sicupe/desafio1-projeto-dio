# 1 Introdução ao Desenvolvimento Moderno de Software
## 1.1 Sistema Desktop X Sistema Web
* 1.1.1 Sistema Desktop
* 1.1.2 Sistema Web
* 1.1.3 Aplicações Mobile
## 1.2 UX | UI
* 1.2.1 UX Design (User Experience) | Comportamento
* 1.2.2 UI Design (User Interface) | Aparência
## 1.3 DEV Modelo Cliente Servidor
* 1.3.1 IDE
* 1.3.2 Framework
* 1.3.3 API
* 1.3.4 Midiware
## 1.4 Front End
## 1.5 Back End
## 1.6 Full Stack
## 1.7 Quality Assurance (QA)
## 1.8 Nuvem (Cloud Computing)
* 1.8.1 Mobile
* 1.8.2 Hibrido
# 2 Introdução à Programação e Pensamento Computacional
## 2.1 Introdução ao pensamento computacional
* 2.1.1 Sistemático e eficiente
    1. Decomposição
        * Dividir um problema complexo em subproblemas menores
    2. Reconhecimento de padrões
        * Identificar padrões ou tendências
        * Similaridades e diferenças entre os problemas
    3. Abstração
        * Extrapolar o conceito do problema para um forma generalista
    4. Design de algoritmos
        * Automatizar - Definir passo a passo a solução do problema.
        * Ciclo Refinamento - Teste - Análise
        * Definir uma solução
        * Testar a solução
        * Aperfeiçoamento da solução
        * Recursos computacionais - Análise
        * Habildades Humanas - Abstração e Automatização
## 2.2 Habilidade complementares
* 2.2.1 Raciocínio lógico
1. Indução (inferência sintética) - Da observção às leis e torias
2. Dedução (inferência analítica) - Das leis e teorias às previsões e explicações
3. Abdução (inferência sintética) - Da conclusão à premissa
* 2.2.2 Aperfeiçoamento
1. Melhoramento, aprimoramento, refinamento
	* Melhor uso dos recursos
	  a. Encontrar soluções eficientes
	  b. Otimizar Processos
	* Melhorar códigos e algorítimos
	  a. Simplificar linhas de códigos
	  b. Definir bem as funções
## 2.3 Pilares
* 2.3.1 Decomposição (segmentar)
1. Análise
	* Detectar partes gerenciáveis menores
	* Identificar elementos constituintes
2. Síntese
	* Recompor o problema original
	* Reunir os elementos de forma coerente
3. Ordem de execução
	* Sequencial
	  a. Dependência entre as tarefas (em fila)
	* Peralelo
	  a. Tarefas podem ser executadas concomitantemente (mais eficiência menos tempo)
* 2.3.2 Padrões
1. Reconhecimento
	* Possui Modelo base
	* Modelo com Estrutura invariante
	* Apresenta Repetições
2. Comparação
	* Extração de características
	* Classificação de dados
3. Generalização
	* Classes
	* Categorias
* 2.3.3 Abstração
1. Processo de isolamento da realidade
	*  Observar as características comuns
	*  Definir os pontos essenciais
	*  Diferenciar o que é genérico do que é detalhe
2. Extender, tornar mais amplo
* 2.3.4 Algoritmos
1. Processamento dos dados
	* Instruções
	  a. O que precisa ser feito (passo a passo)
	  b. Qual a ordem de execução
	* Desenvolvimento do programa
	  a. Analise - Definição dos dados E/S
	  b. Algorítimo - Descreve o programa (narrativa, fluxograma, pseudocódigo)
	  c. Codificação -  Codifica segundo a linguagem escolhida
2. Como construir
3. Compreenção do problema (pontos mais importantes)
4. Definir dados de entrada (dados fornecidos e cenário)
5. Definir procesamento (cálculos e restrições)
6. Definir dados de saída (após processamento)
7. Método de construção (narrativa, fluxograma e pseudocódigo)
8. Teste e diagnóstico (refinamento)
## 2.4 Introdução à lógica da programação
* 2.4.1 Lógica
1. Problema desordenado
	* Forma como desencadeiam os acontecimentos
	* Forma de raciocínio
	* Oganização coesa
	* Oganização seguindo convenções
2. Sequência de instruções
	* Instruções detalhadas
	  a. Técnica linear
	  b. Técnica estruturada
	  c. Técnica modular
## 2.5  Fundamentos de Algoritmos
* 2.5.1 Tipologia e variáveis
1. Tipos de dados
	* Numéricos - Inteiros & Reais
	* Caractere - Char & String
	* Lógico - Booleano
2. Variáveis
	* Dados + Instruções = Informação
	* Mutavel
	* Inconstante
	* Constante
* 2.5.2 Instruções primitivas
1. Operadores
2. Notação
* 2.5.3 Estruturas condicionais e operadores
1. Condição -> Operação & exceção
2. Simples - composta - encadeada
3. Operadores relacionais
4. Operadores Lógicos
* 2.5.4 Estruturas de repetição
1. Controle de fluxo
	* For - Para (Para...)
	* While - Enquanto (Enquanto...)
	* Do While - Do While (Repita até...)
* 2.5.5 Vetores e matrizes
1. Container
2. Matriz unidimensional
* 2.5.6 O que são funções?
1. Subprograma
	* Decomposição do algoritimo
	* Modularizao o problema
	* Reutilizar instruções
* 2.5.7 Instruções de entrada/saída
1. Instruções de entrada
	* Inserção de dados
2. Instruções de saída
	* Dispositivos de saída
	  a. Saída por interrupção - definida pelos periféricos
	  b. Saída programada - condicional/incondicional aguarda o dispositivo
## 2.6 Linguagens de programação
* 2.6.1 Problemas de decisão
1. Caracter lógico - Sim ou Não
2. Ideia
3. Pertencimento
* 2.6.2 Problemas de busca
1. Relacionamento binário
2. Objetivo
3. Recorrente em teoria de grafos
* 2.6.3 Problemas de otimização
1. Objetivo
2. Aplicações
* 2.6.4 O que é uma linguagem de programação? Como o computador entende o programa?
1. Linguagem - Compilador - Assembly
	* Linguagem de alto nível - Programa Fonte
	* Assembly - Proframa Objeto
	1. Código fonte -> Tradução
		*  Geração do programa objeto - Execução mais rápida
		* Execução do programa objeto - Programas menores
	2. Código fonte -> Interpretação
		* Programa fonte executado diretamente - Maior flexibilidade
* 2.6.5 Características de um programa
1. Desenvolvimento de programas (Diretrizes)
	* Legibilidade
	a. Facilidade de leitura
	b. Compreensão
	c. Ortogonalidade
	d. Definição adequada das estruturas
	* Redigibilidade
	a. Pode conflitar com a legibilidade
	b. Ortogonalidade
	c. Simplicidade da escrita
	d. Suporte à abstração
	e. Reuso do código
	f. Expressividade
	* Confiabilidade
	a. verificação de tipos
	b. Trata exceções
	c. Uso de ponteiros
	d. Compatibilidade entre compiladores
	* Custo
	a. Treinamento
	b. Codificação
	c. Compilação
	d. Execução
	e. Infra-estrutura
	* Atualizações
	* Uso para IA
	* Disponibilidade de ferramentas
	* Comunidade ativa
	* Adoção pelo mercado
2. Análises de código
	* Análise léxica
	a. Particionar -> Classificar -> Eliminar
	* Análise sintática (Forma)
	b. Sintaxe
	* Análise semântica
	c. Significado
3. Paradigmas de programação
	* Orientação à objeto
	* Procedural - Camadas sucessivas e procedimentos separados
	* Funcional - Instruções são baseadas em funções
	* Estruturado - Estrutura de blocos alinhados
	* Computação distribuída - Funções executadas de forma independente
	* Lógico
4. Paradigma Estruturado
	* Sequência
	* Decisão - Teste lógico
	* Iteração - Funções, laços e condições
5. Orientação a objeto
	* Modelo - Atributos, métodos e estados
	* Pilares da orientação a objeto
	  a. Herança
	  b. Ecapsulamento
	  c. Polimorfismo
	  d. Abstração
